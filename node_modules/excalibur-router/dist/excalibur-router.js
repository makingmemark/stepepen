import { Scene as O, Actor as f, Canvas as w, Util as p, Color as u, Class as m, GameEvent as L, ScreenElement as y } from "excalibur";
class x extends O {
  constructor() {
    super(...arguments), this.labels = [], this.elapsedTime = 0, this.complete = !1;
  }
  onInitialize(t) {
    const e = {
      sm: Math.max(t.drawHeight, t.drawWidth) / 28,
      lg: Math.max(t.drawHeight, t.drawWidth) / 10
    };
    this.progressBar = new v({
      x: t.drawWidth / 2,
      y: t.drawHeight / 2,
      width: t.drawWidth * 0.75,
      height: Math.round(e.sm)
    }), t.add(this.progressBar);
  }
  onActivate() {
    this.complete = !1;
  }
  onLoad(t) {
    this.progressBar.progress = t;
  }
  onLoadComplete() {
    this.complete = !0, this.progressBar.actions.clearActions();
  }
  onPreUpdate(t, e) {
    this.elapsedTime += e;
  }
}
class v extends f {
  constructor(t) {
    super(t), this.progress = 0;
  }
  onInitialize(t) {
    const e = new w({
      width: this.width,
      height: this.height,
      quality: window.devicePixelRatio,
      draw: (s) => {
        p.DrawUtil.roundRect(s, 0, 0, this.width, this.height, this.height / 2, u.White), p.DrawUtil.roundRect(s, 0, 0, this.width * Math.max(0.05, Math.min(1, this.progress / 100)), this.height, this.height / 2, u.White, u.White);
      }
    });
    this.graphics.use(e);
  }
}
class T extends m {
  constructor(t) {
    super(), this.data = [], this.canvas = { draw() {
    } }, this.addResources(t != null ? t : []);
  }
  async load() {
    let t = 0;
    const e = this.data.filter((i) => !i.isLoaded());
    this.emit("start", e), this.emit("progress", new l(this, 0));
    const s = await Promise.all(e.map((i) => i.load().finally(() => {
      t++, this.emit("progress", new l(this, t / e.length * 100));
    })));
    return this.emit("progress", new l(this, 100)), this.emit("complete", e), s;
  }
  addResources(t) {
    this.data.push(...t.filter((e) => !e.isLoaded()));
  }
  isLoaded() {
    return this.data.every((t) => t.isLoaded());
  }
  wireEngine() {
  }
  update() {
  }
  draw() {
  }
}
class l extends L {
  constructor(t, e) {
    super(), this.target = t, this.progress = e;
  }
}
class R extends m {
  constructor(t) {
    super(), this.isTransitioning = !1, this.isBooting = !0, this.resourceLoader = new T(), this.routes = t.routes, this.loaders = {
      default: x,
      ...t.loaders
    };
  }
  get location() {
    const t = Object.keys(this.routes).find((e) => this.engine.scenes[e] === this.engine.currentScene);
    return t || console.warn("Unable to determine name for current scene, was it loaded outside of the router?"), {
      ...this.lastGoto,
      name: t,
      scene: this.engine.currentScene
    };
  }
  start(t) {
    return this.engine = t, this.isBooting = !0, Object.entries(this.routes).forEach(([e, s]) => {
      g(s) && this.engine.add(e, new s());
    }), Object.entries(this.loaders).forEach(([e, s]) => {
      this.engine.add(e, new s());
    }), t.start(null);
  }
  addRoute(t, e) {
    this.routes[t] = e, g(e) && this.engine.add(t, new e());
  }
  removeRoute(t) {
    delete this.routes[t], delete this.engine.scenes[t];
  }
  async goto(t, e = {}) {
    const s = e.transition;
    this.emit("navigationstart", { to: t, ...e }), this.engine.currentScene.transition && this.engine.currentScene.transition.kill(), this.engine.currentScene.transition = s;
    let i = this.engine.scenes[t];
    if (!this.routes[t])
      throw new Error(`No scene named ${t}`);
    return this.sceneNeedsLoading(t) ? i = await this.loadScene(t, e) : await this.executeTransition({
      type: "outro",
      transition: s
    }), i.once("activate", () => {
      var r;
      (r = e.onActivate) == null || r.call(e, i);
    }), this.engine.goToScene(t, e.data), this.lastGoto = { name: t, data: e.data }, this.emit("navigation", {
      to: t,
      ...e
    }), await this.executeTransition({
      type: "intro",
      transition: s
    }), this.engine.currentScene.transition = null, this.emit("navigationend", {
      to: t,
      ...e
    }), this.isBooting = !1, i;
  }
  async preloadScene(t) {
    var s, i;
    let e = this.engine.scenes[t];
    if (this.sceneNeedsLoading(t)) {
      if (!e) {
        const a = this.routes[t], c = g(a) ? a : await a().then((n) => n.default ? n.default : n);
        if (c)
          e = new c(), e.name = t, this.engine.add(t, e);
        else
          throw new Error(`"${t}" did not return a Scene`);
      }
      const r = this.engine.currentScene, d = new Promise((a) => {
        r.defer ? r.once("continue", a) : a(void 0);
      });
      (s = r.onLoadStart) == null || s.call(r);
      const h = ({ progress: a }) => {
        var c, n;
        (n = (c = this.engine.currentScene).onLoad) == null || n.call(c, a);
      };
      this.resourceLoader.on("progress", h), await this.resourceLoader.load(), (i = r.onLoadComplete) == null || i.call(r), this.resourceLoader.off("progress", h), await d;
    }
    return e;
  }
  async loadScene(t, e = {}) {
    var r;
    const s = e.transition, i = (r = e.loader) != null ? r : "default";
    if (this.sceneNeedsLoading(t)) {
      this.isBooting || await this.executeTransition({
        type: "outro",
        transition: s
      }), this.engine.goToScene(i);
      let d, h = Boolean(s && this.isBooting);
      !this.isBooting && s && (s.persistOnLoading !== !1 && this.engine.currentScene.add(s), typeof s.persistOnLoading == "number" ? d = setTimeout(() => {
        this.executeTransition({
          type: "intro",
          transition: s
        }), h = !0;
      }, s.persistOnLoading) : s.persistOnLoading === !1 && (await this.executeTransition({
        type: "intro",
        transition: s
      }), h = !0)), await this.preloadScene(t), h && (this.isBooting && this.engine.currentScene.add(s), await this.executeTransition({
        type: "outro",
        transition: s
      })), clearTimeout(d);
    }
    return this.engine.scenes[t];
  }
  addResource(t) {
    return this.resourceLoader.addResources(Array.isArray(t) ? t : [t]);
  }
  async restartScene(t = {}) {
    var i;
    const e = this.lastGoto.name;
    if (!e)
      throw new Error("Scene was not navigated to using router, unable to restart.");
    await this.executeTransition({
      type: "outro",
      transition: t.transition
    });
    const s = this.engine.currentScene;
    this.engine.remove(s), this.addRoute(e, this.routes[e]), await this.goto(e, {
      ...t,
      transition: null,
      data: (i = t.data) != null ? i : this.lastGoto.data
    }), await this.executeTransition({
      type: "intro",
      transition: t.transition
    });
  }
  sceneNeedsLoading(t) {
    return this.engine.scenes[t] ? !this.resourceLoader.isLoaded() : !0;
  }
  async executeTransition({
    type: t,
    transition: e,
    progress: s = 0
  }) {
    var r, d, h, a;
    const i = this.engine.currentScene;
    return e && (this.isTransitioning = !0, i.isTransitioning = !0, i.add(e), t === "outro" ? (r = i.onOutroStart) == null || r.call(i) : (d = i.onIntroStart) == null || d.call(i), e.on("outro", (c) => {
      var n;
      (n = i.onOutro) == null || n.call(i, c);
    }), e.on("intro", (c) => {
      var n;
      (n = i.onIntro) == null || n.call(i, c);
    }), await e.execute(t === "outro", s), t === "intro" ? ((h = i.onIntroComplete) == null || h.call(i), e.kill()) : (a = i.onOutroComplete) == null || a.call(i), i.isTransitioning = !1, this.isTransitioning = !1), e;
  }
}
function g(o) {
  return I(o);
}
function I(o) {
  if (typeof o != "function")
    return !1;
  const t = Object.getOwnPropertyDescriptor(o, "prototype");
  return t ? !t.writable : !1;
}
class S extends f {
  constructor({
    duration: t = 300,
    easing: e = (i) => i,
    ...s
  } = {}) {
    super(s), this.isOutro = !1, this.progress = 0, this.started = !1, this.duration = typeof t == "number" ? { outro: t, intro: t } : t, this.easing = e, this.persistOnLoading = s.persistOnLoading, this.on("preupdate", (i) => {
      this.started && (this.progress += Math.min(i.delta / this.getDuration(), 1), this.emit(this.isOutro ? "outro" : "intro", this.easing(this.progress)), this.progress >= 1 && (this.emit(this.isOutro ? "outrocomplete" : "introcomplete", void 0), this.started = !1, this.progress = 0));
    }), this.on("introstart", this.onIntroStart.bind(this)), this.on("intro", this.onIntro.bind(this)), this.on("introcomplete", this.onIntroComplete.bind(this)), this.on("outrostart", this.onOutroStart.bind(this)), this.on("outro", this.onOutro.bind(this)), this.on("outrocomplete", this.onOutroComplete.bind(this));
  }
  getDuration() {
    return this.isOutro ? this.duration.outro : this.duration.intro;
  }
  onIntroStart() {
  }
  onIntro(t) {
  }
  onIntroComplete() {
  }
  onOutroStart() {
  }
  onOutro(t) {
  }
  onOutroComplete() {
  }
  async execute(t, e = 0) {
    return this.isOutro = t, this.isInitialized || await new Promise((s) => {
      this.on("initialize", s);
    }), this.started = !0, this.progress = e, this.emit(t ? "outrostart" : "introstart", void 0), new Promise((s) => {
      this.on(t ? "outrocomplete" : "introcomplete", () => {
        s(null);
      });
    });
  }
}
class b extends S {
  constructor(t = {}) {
    super({
      duration: 300,
      z: 1 / 0,
      persistOnLoading: 200,
      ...t
    });
  }
  onInitialize(t) {
    this.el = new y({
      x: -1,
      y: -1,
      z: this.z,
      width: t.canvasWidth + 1 * 2,
      height: t.canvasHeight + 1 * 2,
      color: u.Black
    }), this.el.graphics.opacity = this.isOutro ? 0 : 1, this.addChild(this.el), this.el.scene = this.scene;
  }
  onIntroStart() {
    this.el.graphics.opacity = 1;
  }
  onOutroStart() {
    this.el.graphics.opacity = 0;
  }
  onIntro(t) {
    this.el.graphics.opacity = 1 - t;
  }
  onOutro(t) {
    this.el.graphics.opacity = t;
  }
}
class B extends S {
  constructor({ duration: t, ...e } = {}) {
    super({
      ...e,
      duration: {
        outro: 0,
        intro: t != null ? t : 150
      },
      z: 1 / 0
    });
  }
  onInitialize(t) {
    this.el = new y({
      x: 0,
      y: 0,
      z: this.z,
      width: t.canvasWidth,
      height: t.canvasHeight
    }), this.el.graphics.use(new w({
      quality: window.devicePixelRatio,
      width: t.canvasWidth,
      height: t.canvasHeight,
      draw: (e) => {
        this.screenshot && e.drawImage(this.screenshot, 0, 0, t.canvasWidth, t.canvasHeight, 0, 0, t.canvasWidth / t.pixelRatio, t.canvasHeight / t.pixelRatio);
      }
    })), this.addChild(this.el);
  }
  onIntroStart() {
    this.el.graphics.opacity = 1;
  }
  onOutroStart() {
    this.takeScreenshot();
  }
  onIntro(t) {
    this.el.graphics.opacity = 1 - t;
  }
  onOutro(t) {
  }
  onOutroComplete() {
  }
  takeScreenshot() {
    this.scene.engine.screenshot(!0).then((t) => {
      this.screenshot = t;
    });
  }
}
export {
  B as CrossFadeTransition,
  x as DefaultLoader,
  b as FadeTransition,
  R as Router,
  S as Transition
};
